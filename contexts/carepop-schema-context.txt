Okay, here is a proposed initial database schema for the CarePoP/QueerCare platform, designed for Supabase (PostgreSQL) and incorporating elements from the revised PRD and Technical Spike.

Key Considerations:

Supabase Auth: User authentication is primarily handled by Supabase Auth. We'll have a profiles table linked to auth.users.

RLS (Row Level Security): This is fundamental. Almost every table will need RLS policies. The policies described below are examples of intent; the exact SQL implementation needs careful design and testing. RLS is the primary mechanism for ensuring users only see their own data unless explicitly permitted otherwise (e.g., Admins, Providers viewing consented patient data).

Application-Level Encryption: Specific sensitive fields (marked with [ENCRYPTED]) require encryption before being stored in the database, likely handled within Google Cloud Run functions. The database will store the encrypted ciphertext (e.g., as TEXT or BYTEA).

SPI/PHI: Fields likely containing Sensitive Personal Information (SPI) under DPA or Protected Health Information (PHI) under HIPAA are marked [SPI/PHI]. These require the strictest RLS and application-level encryption.

UUIDs: Using UUIDs for primary keys is standard practice with Supabase.

JSONB: Used for flexible data structures like settings, symptoms, or granular consent.

PostGIS: The postgis extension must be enabled in Supabase for geographic features.

-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS postgis; -- For geographic data types and functions
CREATE EXTENSION IF NOT EXISTS moddatetime; -- For automatically updating updated_at timestamps

-- ========== Core User & Auth Schema ==========

-- Supabase handles auth.users table automatically.
-- We create a profiles table linked to it.

CREATE TABLE public.profiles (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE, -- Links to Supabase Auth user
  first_name TEXT,
  last_name TEXT,
  date_of_birth DATE,                                 -- [SPI/PHI]
  phone_number TEXT UNIQUE,                           -- [SPI/PHI] Potentially needs formatting/validation
  address TEXT,                                       -- [SPI/PHI]
  -- Add other demographic fields as needed, evaluate SPI implications
  -- Granular consent flags (DPA/HIPAA focus)
  granular_consents JSONB DEFAULT '{}'::jsonb,        -- [SPI/PHI] e.g., {'allow_general_data_processing': true, 'allow_tracking_data_view_by_provider_<provider_id>': 'granted'}
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
-- Trigger to update 'updated_at' timestamp
CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);

-- RLS Policy for Profiles: Users can manage their own profile.
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow individual read access" ON public.profiles FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow individual update access" ON public.profiles FOR UPDATE USING (auth.uid() = user_id);
-- No delete policy initially? Or allow self-delete?

-- RBAC - Roles (Simple Role System)
CREATE TABLE public.roles (
  id SERIAL PRIMARY KEY,
  name TEXT UNIQUE NOT NULL -- e.g., 'Patient', 'Provider', 'Admin', 'InventoryManager'
);

-- RBAC - User Roles Mapping
CREATE TABLE public.user_roles (
  user_id UUID REFERENCES public.profiles(user_id) ON DELETE CASCADE,
  role_id INTEGER REFERENCES public.roles(id) ON DELETE CASCADE,
  PRIMARY KEY (user_id, role_id)
);
CREATE INDEX idx_user_roles_user_id ON public.user_roles(user_id);

-- RLS Policy for User Roles: Users cannot see/edit roles. Admins can manage roles.
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
-- Example: Allow Admins (identified by a role ID, e.g., 3) to manage roles
-- This might require a function or checking against a known Role ID or a more complex lookup.
-- CREATE POLICY "Allow admin full access" ON public.user_roles FOR ALL USING (is_admin(auth.uid())); -- Assuming is_admin() function exists

-- ========== Provider & Facility Directory ==========

CREATE TABLE public.facilities (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  address TEXT,
  phone_number TEXT,
  email TEXT,
  coordinates geometry(Point, 4326), -- Requires PostGIS extension
  services_offered TEXT[],          -- Array of service names/tags
  accessibility_info TEXT,
  is_active BOOLEAN DEFAULT true NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
CREATE INDEX idx_facilities_coordinates ON public.facilities USING GIST (coordinates); -- Geo index
CREATE INDEX idx_facilities_name ON public.facilities USING GIN (to_tsvector('simple', name)); -- For text search
CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.facilities
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);

-- RLS Policy for Facilities: Public read, Admin write.
ALTER TABLE public.facilities ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read access" ON public.facilities FOR SELECT USING (true);
CREATE POLICY "Allow admin write access" ON public.facilities FOR ALL USING (is_admin(auth.uid())); -- Assuming is_admin function

CREATE TABLE public.providers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID UNIQUE REFERENCES public.profiles(user_id) ON DELETE SET NULL, -- If provider has a login
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  credentials TEXT, -- e.g., "MD", "RN"
  contact_email TEXT,
  contact_phone TEXT,
  consultation_hours JSONB, -- Flexible structure for hours
  languages_spoken TEXT[],
  is_lgbtqia_affirming BOOLEAN DEFAULT false,
  is_active BOOLEAN DEFAULT true NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
CREATE INDEX idx_providers_user_id ON public.providers(user_id);
CREATE INDEX idx_providers_name ON public.providers USING GIN (to_tsvector('simple', first_name || ' ' || last_name));
CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.providers
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);

-- RLS Policy for Providers: Public read, Admin write, Provider self-write (if logged in).
ALTER TABLE public.providers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read access" ON public.providers FOR SELECT USING (true);
CREATE POLICY "Allow admin write access" ON public.providers FOR ALL USING (is_admin(auth.uid()));
CREATE POLICY "Allow provider self-update" ON public.providers FOR UPDATE USING (auth.uid() = user_id); -- Requires user_id link

CREATE TABLE public.specialties (
  id SERIAL PRIMARY KEY,
  name TEXT UNIQUE NOT NULL
);

CREATE TABLE public.provider_specialties (
  provider_id UUID REFERENCES public.providers(id) ON DELETE CASCADE,
  specialty_id INTEGER REFERENCES public.specialties(id) ON DELETE CASCADE,
  PRIMARY KEY (provider_id, specialty_id)
);

CREATE TABLE public.provider_facilities (
  provider_id UUID REFERENCES public.providers(id) ON DELETE CASCADE,
  facility_id UUID REFERENCES public.facilities(id) ON DELETE CASCADE,
  PRIMARY KEY (provider_id, facility_id)
);
-- Add RLS for provider_specialties and provider_facilities if needed (e.g., Admins manage)

-- ========== Appointment Scheduling ==========

CREATE TYPE public.appointment_status AS ENUM (
  'Pending Confirmation',
  'Confirmed',
  'Cancelled by User',
  'Cancelled by Provider',
  'Completed',
  'No Show'
);

CREATE TABLE public.appointments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(user_id) ON DELETE CASCADE,      -- Patient
  provider_id UUID REFERENCES public.providers(id) ON DELETE SET NULL, -- Optional link
  facility_id UUID NOT NULL REFERENCES public.facilities(id) ON DELETE CASCADE,
  appointment_time TIMESTAMPTZ NOT NULL,
  duration_minutes INTEGER DEFAULT 30, -- Default duration
  service_type TEXT,                   -- e.g., 'Consultation', 'Family Planning Session'
  status appointment_status DEFAULT 'Pending Confirmation' NOT NULL,
  cancellation_reason TEXT, -- Optional reason
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
CREATE INDEX idx_appointments_user_id ON public.appointments(user_id);
CREATE INDEX idx_appointments_provider_id ON public.appointments(provider_id);
CREATE INDEX idx_appointments_facility_id ON public.appointments(facility_id);
CREATE INDEX idx_appointments_time ON public.appointments(appointment_time);
CREATE INDEX idx_appointments_status ON public.appointments(status);
CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.appointments
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);

-- RLS Policy for Appointments: User sees own, Provider sees theirs, Admin sees all. Strict logic for create/update.
ALTER TABLE public.appointments ENABLE ROW LEVEL SECURITY;
CREATE POLICY "User can see own appointments" ON public.appointments FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "User can create own appointments" ON public.appointments FOR INSERT WITH CHECK (auth.uid() = user_id);
-- CREATE POLICY "User can cancel own appointments (if Confirmed)" ON public.appointments FOR UPDATE USING (auth.uid() = user_id AND status = 'Confirmed') WITH CHECK (... only status changes to 'Cancelled by User'); -- Complex CHECK needed
-- CREATE POLICY "Provider can see their appointments" ON public.appointments FOR SELECT USING (is_provider_for_appointment(auth.uid(), id)); -- Assumes helper function
-- CREATE POLICY "Provider can confirm/cancel/complete their appointments" ON public.appointments FOR UPDATE USING (is_provider_for_appointment(auth.uid(), id)); -- Needs complex check
-- CREATE POLICY "Admin can see all appointments" ON public.appointments FOR SELECT USING (is_admin(auth.uid()));
-- CREATE POLICY "Admin can manage all appointments" ON public.appointments FOR ALL USING (is_admin(auth.uid())); -- Simplified, maybe too broad


-- Provider Availability - Simplified MVP: Storing simple blocks, more complex rules later
CREATE TABLE public.provider_availability (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  provider_id UUID NOT NULL REFERENCES public.providers(id) ON DELETE CASCADE,
  facility_id UUID NOT NULL REFERENCES public.facilities(id) ON DELETE CASCADE,
  start_time TIMESTAMPTZ NOT NULL,
  end_time TIMESTAMPTZ NOT NULL,
  -- Add recurrence rules / flags here if needed for Phase 2/3
  is_booked BOOLEAN DEFAULT false NOT NULL, -- Simplistic lock mechanism (better handled by checking appointments table)
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
CREATE INDEX idx_provider_availability_provider ON public.provider_availability(provider_id);
CREATE INDEX idx_provider_availability_facility ON public.provider_availability(facility_id);
CREATE INDEX idx_provider_availability_times ON public.provider_availability(start_time, end_time);
CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.provider_availability
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);

-- RLS Policy for Provider Availability: Provider manages own, Admin manages all. Read might be more open depending on booking flow.
ALTER TABLE public.provider_availability ENABLE ROW LEVEL SECURITY;
-- CREATE POLICY "Provider manages own availability" ON public.provider_availability FOR ALL USING (auth.uid() = (SELECT user_id FROM providers WHERE id = provider_id));
-- CREATE POLICY "Admin manages all availability" ON public.provider_availability FOR ALL USING (is_admin(auth.uid()));
-- CREATE POLICY "Authenticated users can read availability?" ON public.provider_availability FOR SELECT USING (auth.role() = 'authenticated'); -- Depends on booking flow

-- ========== Health Tracking (SPI/PHI - High Sensitivity) ==========

CREATE TYPE public.pill_intake_status AS ENUM ('Taken', 'Missed', 'Skipped');

CREATE TABLE public.pill_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(user_id) ON DELETE CASCADE, -- Owner
  -- medication_name TEXT NOT NULL, -- Less secure
  -- medication_details TEXT, -- Includes dose etc. Less secure
  encrypted_medication_data TEXT,   -- [ENCRYPTED] [SPI/PHI] Store encrypted JSON/string with name, dose, schedule etc.
  logged_at TIMESTAMPTZ NOT NULL,   -- Time the dose was due or taken/missed
  status pill_intake_status NOT NULL,
  reminder_config JSONB,            -- Configuration for reminders associated with this medication/log type
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
CREATE INDEX idx_pill_logs_user_id_logged_at ON public.pill_logs(user_id, logged_at DESC);
CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.pill_logs
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);

-- RLS Policy for Pill Logs: User owns their data ONLY. Provider access VERY restricted (needs consent check).
ALTER TABLE public.pill_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "User manages own pill logs" ON public.pill_logs FOR ALL USING (auth.uid() = user_id);
-- Provider access would require complex RLS joining consent data from profiles.granular_consents JSONB
-- CREATE POLICY "Provider read access with consent" ON public.pill_logs FOR SELECT USING (has_patient_consent(auth.uid(), user_id, 'pill_tracker')); -- Assumes function

CREATE TABLE public.menstrual_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(user_id) ON DELETE CASCADE, -- Owner
  log_date DATE NOT NULL,
  is_cycle_start BOOLEAN DEFAULT false,
  is_cycle_end BOOLEAN DEFAULT false,
  flow_intensity INTEGER, -- e.g., 1-5 scale
  symptoms TEXT,                     -- [ENCRYPTED] [SPI/PHI] Store encrypted JSON array or tags
  notes TEXT,                        -- [ENCRYPTED] [SPI/PHI] Free-text notes
  reminder_config JSONB,             -- Configuration for cycle-related reminders
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
CREATE INDEX idx_menstrual_logs_user_id_log_date ON public.menstrual_logs(user_id, log_date DESC);
CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.menstrual_logs
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);

-- RLS Policy for Menstrual Logs: User owns their data ONLY. Provider access VERY restricted (needs consent check).
ALTER TABLE public.menstrual_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "User manages own menstrual logs" ON public.menstrual_logs FOR ALL USING (auth.uid() = user_id);
-- Provider access would require complex RLS joining consent data.
-- CREATE POLICY "Provider read access with consent" ON public.menstrual_logs FOR SELECT USING (has_patient_consent(auth.uid(), user_id, 'menstrual_tracker')); -- Assumes function

-- ========== Inventory Management (Admin Focused) ==========

CREATE TABLE public.inventory_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  category TEXT, -- e.g., 'Medication', 'Testing Kit', 'Supply'
  supplier TEXT,
  unit_of_measure TEXT, -- e.g., 'box', 'bottle', 'kit'
  is_active BOOLEAN DEFAULT true NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
CREATE INDEX idx_inventory_items_name ON public.inventory_items USING GIN (to_tsvector('simple', name));
CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.inventory_items
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);

-- RLS for Inventory Items: Admins / Inventory Managers only
ALTER TABLE public.inventory_items ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow inventory admin access" ON public.inventory_items FOR ALL USING (is_inventory_admin(auth.uid())); -- Assumes function

CREATE TABLE public.stock_levels (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  item_id UUID NOT NULL REFERENCES public.inventory_items(id) ON DELETE CASCADE,
  facility_id UUID NOT NULL REFERENCES public.facilities(id) ON DELETE CASCADE,
  quantity INTEGER NOT NULL DEFAULT 0,
  expiry_date DATE,
  lot_number TEXT,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
CREATE INDEX idx_stock_levels_item_id ON public.stock_levels(item_id);
CREATE INDEX idx_stock_levels_facility_id ON public.stock_levels(facility_id);
CREATE INDEX idx_stock_levels_expiry ON public.stock_levels(expiry_date);
CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.stock_levels
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);

-- RLS for Stock Levels: Admins / Inventory Managers only
ALTER TABLE public.stock_levels ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow inventory admin access" ON public.stock_levels FOR ALL USING (is_inventory_admin(auth.uid())); -- Assumes function


-- ========== Transaction History (Simplified) ==========

CREATE TYPE public.transaction_status AS ENUM ('Completed', 'Pending', 'Failed', 'Refunded');

CREATE TABLE public.transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(user_id) ON DELETE CASCADE,
  transaction_date TIMESTAMPTZ NOT NULL,
  description TEXT NOT NULL,      -- e.g., 'Consultation Fee', 'Donation', 'Medication Purchase'
  amount NUMERIC(10, 2),         -- Optional amount
  status transaction_status DEFAULT 'Completed' NOT NULL,
  payment_method TEXT,            -- e.g., 'GCash', 'Credit Card', 'N/A'
  external_reference TEXT UNIQUE, -- Link to payment gateway transaction ID
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
CREATE INDEX idx_transactions_user_id_date ON public.transactions(user_id, transaction_date DESC);
CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.transactions
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);

-- RLS for Transactions: User views own, Admin views all.
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "User can see own transactions" ON public.transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Admin can see all transactions" ON public.transactions FOR SELECT USING (is_admin(auth.uid()));
-- INSERT likely done by backend service role.

-- ========== Health Records / Lab Results (Simplified MVP) ==========
-- Depends heavily on integration source and how data is structured. Start simple.

CREATE TABLE public.health_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES public.profiles(user_id) ON DELETE CASCADE, -- Patient
    provider_id UUID REFERENCES public.providers(id) ON DELETE SET NULL,         -- Provider who created record
    facility_id UUID REFERENCES public.facilities(id) ON DELETE SET NULL,       -- Where record was created
    visit_date TIMESTAMPTZ NOT NULL,
    encrypted_notes TEXT, -- [ENCRYPTED] [SPI/PHI] Free text notes, assessment, summary etc.
    -- Add structured fields later if needed (vitals, diagnoses codes)
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
CREATE INDEX idx_health_records_user_id_visit_date ON public.health_records(user_id, visit_date DESC);
CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.health_records
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);

-- RLS for Health Records: User sees own. Provider access strictly controlled by consent + assignment. Admin maybe audit access?
ALTER TABLE public.health_records ENABLE ROW LEVEL SECURITY;
CREATE POLICY "User can see own health records" ON public.health_records FOR SELECT USING (auth.uid() = user_id);
-- CREATE POLICY "Provider read access with consent/assignment" ON public.health_records FOR SELECT USING (has_access_to_patient_record(auth.uid(), user_id)); -- Complex function needed
-- CREATE POLICY "Admin can manage health records" ON public.health_records FOR ALL USING (is_admin(auth.uid())); -- CAUTION: Admins shouldn't generally view PHI unless specific role


CREATE TABLE public.lab_results (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES public.profiles(user_id) ON DELETE CASCADE, -- Patient
    provider_id UUID REFERENCES public.providers(id) ON DELETE SET NULL,         -- Ordering Provider
    facility_id UUID REFERENCES public.facilities(id) ON DELETE SET NULL,       -- Reporting Facility
    test_date TIMESTAMPTZ NOT NULL,
    test_name TEXT NOT NULL,
    encrypted_result_data TEXT, -- [ENCRYPTED] [SPI/PHI] Contains value, units, range, interpretation etc.
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
CREATE INDEX idx_lab_results_user_id_test_date ON public.lab_results(user_id, test_date DESC);
CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.lab_results
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);

-- RLS for Lab Results: User sees own. Provider access strictly controlled. Admin access very limited.
ALTER TABLE public.lab_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "User can see own lab results" ON public.lab_results FOR SELECT USING (auth.uid() = user_id);
-- CREATE POLICY "Provider read access with consent/assignment" ON public.lab_results FOR SELECT USING (has_access_to_patient_record(auth.uid(), user_id)); -- Complex function needed
-- CREATE POLICY "Admin can manage lab results" ON public.lab_results FOR ALL USING (is_admin(auth.uid())); -- CAUTION


-- ========== Helper Functions (Example Stubs for RLS) ==========
-- These need proper implementation based on your exact RBAC/ABAC logic

-- Placeholder function to check if the current user is an admin
CREATE OR REPLACE FUNCTION public.is_admin(user_id_check uuid)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER -- Important for checking roles securely
AS $$
BEGIN
  -- Logic to check if user_id_check has the 'Admin' role in user_roles table
  -- Example:
  RETURN EXISTS (
    SELECT 1
    FROM public.user_roles ur
    JOIN public.roles r ON ur.role_id = r.id
    WHERE ur.user_id = user_id_check AND r.name = 'Admin'
  );
END;
$$;

-- Placeholder for inventory admin check
CREATE OR REPLACE FUNCTION public.is_inventory_admin(user_id_check uuid)
RETURNS boolean
LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN RETURN is_admin(user_id_check); END; $$; -- Or check a specific 'InventoryManager' role

-- Placeholder for complex patient data access check (Needs granular_consents)
CREATE OR REPLACE FUNCTION public.has_access_to_patient_record(provider_user_id uuid, patient_user_id uuid)
RETURNS boolean
LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  provider_id_val UUID;
  consent_granted BOOLEAN;
BEGIN
  -- 1. Check if the requesting user is a provider
  SELECT id INTO provider_id_val FROM public.providers WHERE user_id = provider_user_id;
  IF provider_id_val IS NULL THEN RETURN FALSE; END IF;

  -- 2. Check if provider is assigned to patient (NEEDS ASSIGNMENT TABLE/LOGIC)
  -- Placeholder: Assume assigned for now if provider exists

  -- 3. Check patient consent from profiles.granular_consents
  SELECT (granular_consents ->> ('allow_general_data_view_by_provider_' || provider_id_val::text))::boolean
  INTO consent_granted
  FROM public.profiles
  WHERE user_id = patient_user_id;

  RETURN COALESCE(consent_granted, FALSE); -- Default deny if consent field missing or null
END;
$$;


Important Next Steps:

Review & Refine: This schema needs careful review against the detailed requirements of each module (from Epics/Tickets).

Implement RLS Carefully: The placeholder RLS policy logic (especially for provider/admin access to patient data and consent checks) needs precise SQL implementation. Use Supabase helper functions (create policy ... using (check_permission(column_value))) to encapsulate complex logic. Test RLS thoroughly.

Implement Application-Level Encryption: Plan exactly how and where (likely in Cloud Run Functions) the fields marked [ENCRYPTED] will be encrypted/decrypted using AES-256-GCM and keys from Google Cloud Secret Manager.

Data Types & Constraints: Refine data types (e.g., lengths for TEXT where appropriate) and add CHECK constraints if needed (e.g., for numeric ranges).

Migration: Implement this schema using Supabase migrations.

Indexing Strategy: Continuously review and refine indexing based on actual query performance.

Compliance: Ensure this schema design, especially RLS and encryption strategy, is reviewed by compliance experts against DPA and HIPAA requirements.